Let's start by installing Express.js.

### Adding new dependency
To add Express.js to the project, we need to include it as a dependency with the specified version in **package.json**:

```json
  "dependencies": {
    "express": "^4.18.2"
  }
```  

All dependencies can be installed before running the application using a single command: `npm install`. 

> _For this course, all dependencies have already been installed when you opened the course, so you don’t need to take any additional steps._

<div class="hint" title="package-lock.json">

  The **package-lock.json** file is automatically generated by `npm` when you run `npm install`. 
  It contains an exact, locked-down dependency tree for your project to avoid version inconsistency.
</div>

---

### Creating Express app
Now, take a look at the code in **index.js**.
It has exactly the same functionality as the code from the [Hello world](course://Backend/GettingStartedNode/hello_world) task but is much better structured.

First, we create an Express application object `app` and then work exclusively with it.

---

### Adding route handlers
HTTP defines various request methods to specify the purpose of a request and the expected result upon its success. 
For example, the `GET` method requests a representation of the specified resource. You can read more about HTTP request methods [here](https://developer.mozilla.org/en-US/docs/Web/HTTP/Reference/Methods).  

Previously, our handlers did not account for request methods, and that wasn’t entirely correct.
To add a new `GET` handler in Express, use the `app.get` method. The first argument is the route, and the second is the handler.

```js
app.get('/', (req, res) => {
    res.status(200).type('text/plain').send('Hello, World!');
});
```

Here, the handler uses a pattern called *method chaining* to set the status code, content type, and response body. 
Each method call on the `res` object returns the `res` object itself. This allows multiple methods to be called sequentially on the same object in a single statement.

Now, take a look at this special handler:
```js  
app.use((req, res) => {
    res.status(404).type('text/plain').send('Page Not Found');
});
```  
- `app.use` is a general-purpose method to define *middleware*, which we’ll discuss in detail in the next lesson. For now, you can think of it as a handler for all requests.
- Since no path is specified in this `app.use` statement, it applies globally to all routes.
- Placing this handler at the end ensures it only catches undefined routes — those not explicitly handled before this.
- Try moving this declaration to the top, and you’ll see that every route now responds with `Page Not Found`.

---

### Creating HTTP server and running it
When creating the HTTP server, the only thing we pass to the `createServer` method is the `app` object, which already contains everything we need.  

Run the application to ensure it behaves exactly as it did before implementing Express.

### Reminder
_Click the ![](images/run.svg) button in **package.json** to start the application. Click ![](images/stop.svg) in the toolbar at the bottom to stop it._

_If you make changes to your code, remember to restart the application. You can also use the ![](images/rerun.svg) button in the toolbar to quickly restart it._  

<style>
img {
  display: inline !important;
}
</style>
