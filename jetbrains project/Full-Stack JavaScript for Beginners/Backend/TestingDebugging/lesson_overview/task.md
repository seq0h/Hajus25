As you may have noticed, things often don’t work perfectly the first time.
This is true whether you are a beginner or an expert with decades of experience.

That’s why it’s vital to learn how to test and debug your applications early, especially when they are still small.

In this lesson, you will learn how to:
- Write tests for your routes.
- Use tests as a self-checking mechanism.
- Add logging to monitor the requests and responses flowing through the server.

### Small components, small tests
Applications are built from small, modular parts that can be easily modified and reused.
When making changes to your code, it's important to test each part to ensure everything still works correctly.
Testing helps keep the application reliable and functional, providing confidence that nothing has been broken.

In this course, each route will have one or more accompanying tests.
Most of these will be provided for you, but in this lesson, you’ll have the opportunity to practice writing your own tests.

### Testing AI-generated code
We are well aware that in today's world, most programming tasks can be easily solved with AI-generated code.
Moreover, we even recommend using it, especially for test generation. 
Modern IDEs like WebStorm or IntelliJ IDEA even allow you to [generate tests](https://www.jetbrains.com/help/webstorm/generate-tests.html) with a single click!

Now you might ask: if the code can be generated by AI, why write tests at all?

The combination of generated code and tests defines a consistent state for your program — 
ensuring that the actual behavior matches the expected behavior.
AI models themselves use tests for self-checking when generating code.

However, AI-generated code may contain errors that tests can help identify.
In theory, tests themselves may also contain errors that align with code errors. 
This is where you, the developer, come into play. Your role is to ensure
that the achieved consistent state (code + running tests) truly reflects the intended program behavior.
